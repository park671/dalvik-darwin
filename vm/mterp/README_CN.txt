Dalvik "mterp" 说明文件

注意：在此文件底部查找重建指令。

==== 概述 ====

这是Dalvik解释器的源代码。原始版本的核心是作为单个C函数实现的，但为了提高性能，我们用汇编重写了它。为了使这个和未来的汇编端口更容易且不易出错，我们采用了模块化方法，允许一次开发一个操作码的平台特定代码。

原始的一体化函数C版本仍然作为“可移植”解释器存在，并使用生成平台特定版本的相同源代码和工具生成。可移植解释器的一种形式包括对分析和调试功能的支持，即使我们有平台优化的实现也会包括在内。

每个配置都有一个“config-*”文件，控制如何生成源代码。源代码写入“out”目录，在那里被Android构建系统捕获。

了解解释器的最佳方式是查看“out”目录中的生成文件，例如 out/InterpC-portstd.c，而不是尝试查看（例如）armv5te中的各个组件部分。

==== 平台特定源代码生成 ====

架构特定的配置文件确定两个生成的输出文件（InterpC-<arch>.c, InterpAsm-<arch>.S）中包含什么。目标是在初始开发和测试期间易于交换C和汇编源代码，并提供一种使用某些操作的架构特定版本的方法（例如，在ARMv6上使用PLD指令或避免在ARMv4T上使用CLZ）。

对解释器操作的两个基本假设是：

汇编版本使用固定大小区域来处理每条指令（例如64字节）。"溢出"代码附加在末尾。
当需要C实现时，汇编版本将所有本地状态打包进一个“胶水”结构体，并将其传递给C函数。从“胶水”中返回时提取状态更新。
“arch”值应该指示具有共同编程特性的架构家族，所以“armv5te”适用于所有ARMv5TE CPU，但可能不向后或向前兼容。（我们可能还想指定ABI模型，例如“armv5te-eabi”，但目前这增加了冗余而没有价值。）

==== 配置文件格式 ====

配置文件从上到下解析。文件中的每一行可能是空的，包含注释（行以‘#’开头），或是命令。

命令包括：

handler-size <bytes>

复制代码
指定汇编区域的大小，以字节为单位。在大多数平台上，这需要是2的幂次方。
import <filename>

arduino
复制代码
指定的文件将立即完整包含。不执行替换。".c" 和 ".h" 文件复制到C输出，".S" 文件复制到asm输出。
asm-stub <filename>

复制代码
每当需要汇编“存根”时，将包含指定的文件。对操作码名称执行文本替换。
op-start <directory>

复制代码
表示操作码列表的开始。必须在任何“op”命令之前。指定的目录是拉取指令文件的默认位置。
op <opcode> <directory>

sql
复制代码
只能在“op-start”之后和“op-end”之前出现。覆盖指定操作码的默认源文件位置。操作码定义将来自指定的文件，例如“op OP_NOP armv5te”将从“armv5te/OP_NOP.S”加载。将应用替换字典（见下文）。
op-end

复制代码
表示操作码列表的结束。看到这个之后，将发出所有256个操作码，然后是任何不适合固定大小指令处理器空间内的代码。
“op”指令的顺序并不重要；生成工具将从VM源代码中提取排序信息。

通常在“op-start”指令中使用大多数操作码当前存在的形式。对于新的端口，你将从“c”开始，并随着你编写指令添加架构特定的“op”条目。完成后，它将默认为目标架构，你插入“c”操作来存根出平台特定的代码。

在“op”命令中指定的<directory>中，“c”目录在两个方面特别：（1）源代码假定为C代码，并将插入到生成的C文件中；（2）当发出C实现时，在汇编源文件中发出“胶水存根”。（生成脚本始终发出256个汇编指令，除非“asm-stub”留空，在这种情况下，它只发出一些标签。）

==== 指令文件格式 ====

汇编指令文件简单地是汇编源的片段。生成工具将提供起始标签，以及段类型和对齐的声明。预期的目标汇编器是GNU“as”，但其他汇编器也可工作（可能需要对生成工具发出的一些伪操作进行调整）。

C文件通过宏做了很多花哨的事情，试图与可移植解释器共享代码。（这预计在未来会减少。）

替换字典应用于所有操作码片段，因为它们附加到输出中。替换可以看起来像“$value”或“${value}”。

字典始终包括：

$opcode - 操作码名称，例如“OP_NOP”
$opnum - 操作码编号，例如OP_NOP的0
$handler_size_bytes - 指令处理器的最大大小，以字节为单位
$handler_size_bits - 指令处理器的最大大小，以2的对数为单位

C和汇编源都将通过C预处理器传递，因此你可以利用C风格的注释和预处理器指令，如“#define”。

一些生成器操作可用。

%include "filename" [subst-dict]

bash
复制代码
包含文件，该文件应类似于“armv5te/OP_NOP.S”。你可以为替换字典指定值，使用标准的Python语法。例如，这个：
  %include "armv5te/unop.S" {"result":"r1"}
将在当前文件位置插入“armv5te/unop.S”，替换“$result”的出现为“r1”。
%default <subst-dict>

复制代码
使用标准的Python语法指定默认替换字典值。如果你想有一个“基本”版本和变体，这很有用。
%break

arduino
复制代码
标识指令处理器主部分（必须适合“handler-size”字节）与“姐妹”代码之间的分割，后者附加到指令处理器块的末尾。
%verify "message"

复制代码
留下关于需要测试什么的提示。（这可能有朝一日会变得更有趣；目前，它在输出生成之前就被剥离了。）
生成工具不会在你的指令超过“handler-size”时打印警告，但如果VM在启动时检测到过大的处理器，它将中止。在具有固定宽度指令的架构上，这很容易处理，在其他架构上你需要计算字节。

==== 从汇编源使用C常量 ====

文件“common/asm-constants.h”中有一些常量值、结构大小和结构成员偏移的定义。格式相当受限，因为使用简单的宏来处理它，以便与C（其中进行验证）和汇编（使用定义）同时使用。

如果文件中的常量失去同步，VM将在启动期间记录错误消息并中止。

==== 开发技巧 ====

如果你需要调试操作码处理器的初始部分，而你的调试代码扩展了它超出处理器大小限制，你可以在顶部插入通用标题：

bash
复制代码
b       ${opcode}_start
%break
${opcode}_start:

如果你已经有一个%break，保留它是可以的——第二个%break被忽略。

==== 重建 ====

如果你更改了任何源文件片段，你需要重建“out”目录中的组合源文件。确保“out”中的文件是可编辑的，然后：

shell
复制代码
$ cd mterp
$ ./rebuild.sh
截至目前，这需要Python 2.5。如果你安装了不同版本的Python，你可能会看到难以理解的错误消息或只是一般性的失败。

最终目标是让构建系统生成必要的输出文件，而不需要这个单独的步骤，但我们还没有准备好在构建中要求Python。